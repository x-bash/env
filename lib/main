# ___X_CMD_ENV_VERSION_CONFIG="
# java=1.1
# node=1.2
# python=1.3
# "

___x_cmd_env_get_version(){
    local pkg_name="${1%=*}"
    local version="${1#*=}"
    if [ "$version" != "$pkg_name" ]; then
        printf "%s\n" "$version"
    else
        x pkg default_version "$pkg_name"
    fi
}

# try = install + activate
___x_cmd_env_try(){
    param:void
    x:trace env/try

    local i
    for i in "$@"; do
        pkg:info "Prepare ${i%=*} $(___x_cmd_env_get_version "$i")"
        if ! x pkg install "${i%=*}" "$(___x_cmd_env_get_version "$i")"; then
            pkg:error "Cannot install package: $i"
            return 1
        fi
    done

    for i in "$@"; do
        x pkg activate "$i"
    done

    ___X_CMD_ENV___VAR_ADD_NO_SETUP="" ___x_cmd_env___var_add "$@"
}

___x_cmd_env_activate(){
    local i
    for i in "$@"; do
        if x pkg activated "$i"; then
            pkg:error "Not activated: $i"
            return 1
        fi

        if x pkg installed "$i"; then
            pkg:error "Not installed: $i"
            return 1
        fi
    done

    for i in "$@"; do
        x pkg activate "$i"
    done
}

___x_cmd_env_deactivate(){
    local i
    for i in "$@"; do
        if ! x pkg activated "$i"; then
            pkg:error "Not activated: $i"
            return 1
        fi
    done

    for i in "$@"; do
        x pkg activate "$i"
    done
}

___x_cmd_env_pkg_activate(){
    while [ $# -gt 0 ]; do
        local pkg_name="${1%=*}"
        ! ___x_cmd_pkg_activated_version_ || x list ":$___X_CMD_ENV_PKG_STACK_${pkg_name}" push "$___X_CMD_PKG_ACTIVATED_VERSION_"
        ___x_cmd_pkg_activate "$i"
        shift
    done
}

___x_cmd_env_pkg_deactivate(){
    while [ $# -gt 0 ]; do
        local pkg_name="${i%=*}"
        ___x_cmd_env_deactivate "$i"
        x list ":$___X_CMD_ENV_PKG_STACK_${pkg_name}" pop_
        ___x_cmd_pkg_dectivate "${pkg_name}=$___X_CMD_LIST_POP_"
        shift
    done
}

___x_cmd_env_var_set(){
    local val
    eval val="\"\$$1\"" || return 1
    x list ":$___X_CMD_ENV_VAR_$1" push "$val"
    eval "$1=\"$2\""
}

___x_cmd_env_var_recover(){
    while [ $# -gt 0 ]; do
        x list ":$___X_CMD_ENV_VAR_$1" pop_
        eval "$1=\"\$$___X_CMD_ENV_VAR_$1\""
        shift
    done
}

# use = try + save-config
___x_cmd_env_use(){
    param:void
    x:trace env/use
    ___x_cmd_env_try "$@" || return

    local backup="$___X_CMD_ENV_VERSION_CONFIG"
    if [ -f "$___X_CMD_ENV_VERSION_CONFIG_PATH" ]; then
        ___X_CMD_ENV_VERSION_CONFIG="$(cat "$___X_CMD_ENV_VERSION_CONFIG_PATH")"
    else
        ___X_CMD_ENV_VERSION_CONFIG=""
    fi

    ___X_CMD_ENV___VAR_ADD_NO_SETUP=1 ___x_cmd_env___var_add "$@"
    ___x_cmd_env_config_save

    ___X_CMD_ENV_VERSION_CONFIG="$backup"
}

___x_cmd_env_unuse(){
    local i
    local pkg_name
    local version
    for i in "$@"; do
        pkg_name="${i%=*}"
        version="$(___x_cmd_env_get_version "$i")"
        pkg:info "Remove $pkg_name $version path: $___X_CMD_PKG_INSTALL_PATH/$pkg_name/$version/bin"
        x pkg uninstall "$pkg_name" "$version"
        x path rm "$___X_CMD_PKG_INSTALL_PATH/$pkg_name/$version/bin"
    done
}

___x_cmd_env_exec()(
    # local arg
    # local s
    # for arg in "$@"; do
    #     case "$arg" in
    #         *=*)        s="$s $arg" ;;
    #         *)          break
    #     esac
    # done
    # eval ___x_cmd_env_use "$s" && "$@"
    param:void
    x:trace env/exec

    local candidate="${1:?Provide package}"
    local pkg_name="${candidate%=*}"
    local version
    version="$(___x_cmd_env_get_version "$candidate")"
    shift
    pkg:info "Execute $pkg_name $version: $*"
    x pkg xbin init "$pkg_name" "$version"
    "___x_cmd_${pkg_name}" "$@"
)

___x_cmd_env_which(){
    local i
    for i in "$@"; do
        x pkg xbin path "${i%=*}" "$(___x_cmd_env_get_version "$i")"
    done
}