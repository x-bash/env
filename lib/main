# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263    # xrc

# Section: ENV ___X_CMD_ENV_PATH

___X_CMD_ENV_PATH="$___X_CMD_ROOT/.env"

# EndSection

# Section: main, run

___x_cmd_env_main() {
    param:scope     "env"
    param:dsl <<A
subcommands:
    ls                      "list all installed environments"
    la                      "list all available environments"
    download                "Download environment"
    install                 "Install environment"
    uninstall               "Remove environment"
    try                     "Set default environment in this shell session"
    use                     "Set global default environment"
    ws                      "Set workspace default environment"

    current                 "Show current environment"
    which                   "Display path of environment installed"

    exec                    "Run an executable with the selected candidates version"
A
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_env_main help
        return 1
    fi

    "___x_cmd_env_main_$PARAM_SUBCMD" "$@"
}

___x_cmd_env_run(){
    local op="${1:?Provide op}";  shift
    local candidate="${1:?Provide candidate}";  shift

    if ! ___x_cmd_env_candidate_has "$candidate"; then
        env_log error "Candidate inexisted: $candidate"
        return 1
    fi

    # TODO: It might be better to have one folder for one language.
    xrc "env/lib/candidate/$candidate"

    local cmd="___x_cmd_env_${candidate}_${op}"
    if command -v "$cmd" >/dev/null; then
        "$cmd" "$@"
    else
        # env_log warn "Candidate ${candidate} has no op: $op, use common $op function."
        "___x_cmd_env_common_${op}" "$candidate" "$@"
    fi
}

# EndSection

# Section: install, uninstall

___x_cmd_env_main_install() {
    # TODO: You can do more better in #2 advise json
    param:scope "env"
    param:dsl <<A
advise:
    #2        ___x_cmd_env_advise_ls_remote_version
options:
    #1        "Environment Candidates" <candidates>:candidates_list
    #2        "Version"                <version>="default"
A
    param:run

    if [ -z "$1" ]; then
        ___x_cmd_env_main_install help
        return 1
    fi
    ___x_cmd_env_run install "$@"
}

___x_cmd_env_main_uninstall(){
    param:scope "env"
    param:dsl <<A
advise:
    #2        ___x_cmd_env_advise_ls_local_version
options:
    #1        "Environment Candidates" <candidates>:candidates_list
    #2        "Version"                <version>
A
    param:run

    if [ -z "$1" ]; then
        ___x_cmd_env_main_uninstall help
        return 1
    fi

    ___x_cmd_env_run uninstall "$@"
}

___x_cmd_env_common_pre_install_check(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide version}"
    case $version in
        default)
            # TODO: Handle the python3 case.
            if command -v "${candidate}" >/dev/null; then
                env_log info "${candidate} is already installed in $(command -v "${candidate}")"
                return 1
            fi
            ;;
    esac

    # Check the candidate version in general way.
    # The path should have no system and platform info.
    local candidate_path="$___X_CMD_ENV_PATH/${candidate}/versions/${version}"
    if [ -d "$candidate_path" ]; then
        env_log info "$candidate $version is already installed in $candidate_path ."
        return 1
    fi

    env_log info "Installing $1 $2"
}

___x_cmd_env_common_uninstall(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide the version}"
    env_log info "Uninstalling $1 $2"

    local candidate_path="$___X_CMD_ENV_PATH/${candidate}/versions/${version}"
    if [ -d "$candidate_path" ]; then
        rm -rf "${candidate_path}"
    else
        env_log  warn "This ${candidate} ${version} is no exist."
        return 1
    fi
    x boot rc del "x-env-$candidate"
    # TODO: remove the shims from $PATH
}

# EndSection

# Section: ls, la

___x_cmd_env_main_ls(){
    param:scope "env"
    param:dsl <<A
options:
    --remote|-r        "List version including remote"
    #1|--candidate     "Environment Candidates" <candidates>:candidates_list
A
    param:run

    if [ -z "$candidate" ]; then
        env_log warn "No candidate specified"
        ___x_cmd_env_main_ls --help
        return 1
    fi

    # TODO: 增加 本地简写版本对应关系 和 全局简写版本对应关系
    # TODO: V8 -> V8.2   --> (Remote) V8.6
    ___x_cmd_env_run ls "$@"
}

___x_cmd_env_common_ls() {
    local candidate="${1:?Provide candidate}"
	if [ -d "$___X_CMD_ENV_PATH/$candidate/versions" ]; then
		for version in $(find "$___X_CMD_ENV_PATH/$candidate/versions" -maxdepth 1 -mindepth 1 \( -type l -o -type d \) -exec basename '{}' \; | sort -r); do
			printf "%s\n" "$version"
		done
	fi
}

___x_cmd_env_main_la(){
    ___x_cmd_env_run la "$@"
}

___x_cmd_env_common_la() {
    :
}

# EndSection

# Section: use, try, ws, shim_dir

___x_cmd_env_main_try(){
    param:scope "env"
    param:dsl <<A
advise:
    #2        ___x_cmd_env_advise_ls_local_version
options:
    #1        "Environment Candidates" <candidates>:candidates_list
    #2        "Version"                <version>="default"
A
    param:run

    ___x_cmd_env_run try "$@"
}

___x_cmd_env_main_use(){
    param:scope "env"
    param:dsl <<A
advise:
    #2        ___x_cmd_env_advise_ls_local_version
options:
    #1        "Environment Candidates" <candidates>:candidates_list
    #2        "Version"                <version>="default"
A
    param:run

    ___x_cmd_env_run use "$@"
}

___x_cmd_env_main_ws(){
    if [ $# -eq 0 ]; then
        : TODO: list workspace environment
    fi

    ___x_cmd_env_run ws "$@"
}

___x_cmd_env_common_use(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide java version}"
    PATH="${___X_CMD_ENV_PATH}/$candidate/shims:$PATH"
    x boot rc add "x-env-$candidate" "PATH=\"${___X_CMD_ENV_PATH}/$candidate/shims:\$PATH\""
	printf "%s" "$version" > "$___X_CMD_ENV_PATH/$candidate/version"
    env_log info "Using $candidate $version . -> $___X_CMD_ENV_PATH/$candidate/version"
    ___x_cmd_env_shim_dir "$candidate" "${version}"
}

___x_cmd_env_common_try(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide python version}"
    PATH="${___X_CMD_ENV_PATH}/$candidate/versions/$version:$PATH"
}

___x_cmd_env_shim_dir(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide version}"
    local version_path=".x-cmd/.env/$candidate/version"
    local versions_path="$___X_CMD_ENV_PATH/$candidate/versions"
    rm -rf "${___X_CMD_ENV_PATH}/$candidate/shims"
    mkdir -p "${___X_CMD_ENV_PATH}/$candidate/shims"

    for name in $versions_path/${version}/bin/* ; do
        printf "%s" "$(cat <<A
#!/usr/bin/env sh
set -e

cur=\$(pwd)
while [ ! "\$cur" = "" ]; do
    if [ -f "\$cur/$version_path" ]; then
        version=\$(cat "\$cur/$version_path")
        exec $versions_path/\$version/bin/${name##*/} "\$@"
        return 0
    fi
    cur=\${cur%/*}
done
## TODO: no found
A
)">"$___X_CMD_ENV_PATH/$candidate/shims/${name##*/}"
        chmod +x "$___X_CMD_ENV_PATH/$candidate/shims/${name##*/}"
    done
}

# EndSection

# Section: current

___x_cmd_env_main_current(){
    param:scope "env"
    param:dsl <<A
options:
    #1        "Environment Candidates" <candidates>:candidates_list
A
    param:run

    ___x_cmd_env_run current "$@"
}

___x_cmd_env_common_current() {
    local candidate="${1:?Provide candidate}"
    local version_path=".x-cmd/.env/$candidate/version"

    cur=$(pwd)
    while [ ! "$cur" = "" ]; do
        if [ -f "$cur/$version_path" ]; then
            printf "%s" "$(cat "$cur/$version_path")"
            return 0
        fi
        cur=${cur%/*}
    done
}

# EndSection

# Section: download, which, exec

___x_cmd_env_main_download(){

    param:scope "env"
    param:dsl <<A
advise:
    #2        ___x_cmd_env_advise_ls_remote_version
options:
    #1        "Environment Candidates" <candidates>:candidates_list
    #2        "Version"                <version>="default"
A
    param:run

    ___x_cmd_env_run download "$@"
}

___x_cmd_env_main_which(){
    ___x_cmd_env_run which "$@"
}

___x_cmd_env_main_exec(){
    param:scope "env"
    param:dsl <<A
advise:
    #2        ___x_cmd_env_advise_ls_local_version
options:
    #1        "Environment Candidates" <candidates>:candidates_list
    #2        "Version"                <version>
A
    param:run


    if [ -z "$1" ]; then
        ___x_cmd_env_main_exec help
        return 1
    fi

    ___x_cmd_env_run exec "$@"
}

___x_cmd_env_common_exec(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide version}" ; shift
    ___x_cmd_env_common_pre_exec_check "${candidate}" "${version}" || return
    local bin_path="${___X_CMD_ENV_PATH}/${candidate}/versions/${version}/bin/${candidate}"

    "$bin_path" "$@"
}

___x_cmd_env_common_pre_exec_check() {
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide the version}"

    local candidate_path="$___X_CMD_ENV_PATH/${candidate}/versions/${version}"
    case $version in
        default)
            # TODO: Handle the python3 case.
            if command -v "${candidate}" >/dev/null; then
                env_log info "${candidate} is already installed in $(command -v "${candidate}")"
                return 1
            fi
            ;;
        *)
            if [ ! -d "${candidate_path}" ]; then
                env_log error "$candidate $version is not installed."
                return 1
            fi
            ;;
    esac

    env_log debug "Exec $1 $2"
}

# EndSection

# Section: Candidate API

___x_cmd_env_candidate_all(){
    printf "%s" "
python
node
go
java
kotlin
"

}

___x_cmd_env_candidate_has(){
    local target="${1:?Provide target}"
    local s="$(___x_cmd_env_candidate_all)"
    if [ "$s" = "${s#*
$target
}" ]; then
        return 1
    fi
    return 0
}

# EndSection

# Section: advise ls_version

___x_cmd_env_advise_ls_remote_version(){
    local candidate_idx="${1:-2}"
    [ -n "$ZSH_VERSION" ] && candidate_idx=$((candidate_idx+1))
    ___x_cmd_env_main_ls -r "${COMP_WORDS[candidate_idx]}"
}

___x_cmd_env_advise_ls_local_version(){
    local candidate_idx="${1:-2}"
    [ -n "$ZSH_VERSION" ] && candidate_idx=$((candidate_idx+1))
    ___x_cmd_env_main_ls "${COMP_WORDS[candidate_idx]}"
}

# EndSection